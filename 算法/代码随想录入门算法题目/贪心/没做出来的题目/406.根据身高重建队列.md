[代码随想录](https://www.programmercarl.com/0406.根据身高重建队列.html#思路)





```java

class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 1. 排序：按身高降序排列，如果身高相同，按 k 值升序
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) {
                return a[1] - b[1];
            }
            return b[0] - a[0];
        });

        // 2. 按顺序插入队列
        List<int[]> queue = new LinkedList<>();
        for (int[] person : people) {
            queue.add(person[1], person); // 按 k 值插入到对应位置
        }

        // 3. 转换为二维数组返回
        return queue.toArray(new int[queue.size()][]);
    }
}
```



这个问题是一个典型的 **贪心算法** 问题，目标是根据每个人的属性重新构造队列。以下是解题思路和实现代码：

------

### **解题思路：**

1. **排序规则：**
   - 首先按身高 h降序排序（高的人先排）。
   - 如果身高相同，则按 k值升序排序（前面需要的人少的排在前面）。
   - 排序后的数组保证了：较高的人优先被安排，而较矮的人在安排时不会影响较高人的 k值。
2. **构造队列：**
   - 遍历排序后的数组，根据每个人的 k 值，将其插入到指定的位置。
   - k值表示该人插入后队列中应有的 k 个身高不小于自己的人的位置。

------

### **代码实现：**

```java


class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 1. 排序：按身高降序排列，如果身高相同，按 k 值升序
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) {
                return a[1] - b[1];
            }
            return b[0] - a[0];
        });

        // 2. 按顺序插入队列
        List<int[]> queue = new LinkedList<>();
        for (int[] person : people) {
            queue.add(person[1], person); // 按 k 值插入到对应位置
        }

        // 3. 转换为二维数组返回
        return queue.toArray(new int[queue.size()][]);
    }
}
```

------

### **输入输出示例：**

#### 示例 1:

```
text复制代码输入: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

#### 解释:

- 排序后：`[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]`
- 插入步骤：
  1. 插入 `[7,0]` -> `[[7,0]]`
  2. 插入 `[7,1]` -> `[[7,0],[7,1]]`
  3. 插入 `[6,1]` -> `[[7,0],[6,1],[7,1]]`
  4. 插入 `[5,0]` -> `[[5,0],[7,0],[6,1],[7,1]]`
  5. 插入 `[5,2]` -> `[[5,0],[7,0],[5,2],[6,1],[7,1]]`
  6. 插入 `[4,4]` -> `[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`

------

### **复杂度分析：**

1. **排序复杂度：** O(nlog⁡n)其中 n 是数组的长度。
2. **插入复杂度：** 每次插入操作为 O(n)，总共 n 次插入，时间复杂度为 O(n2)
3. **总体复杂度：** O(n2)，适合中等规模数据。

------

### **关键点总结：**

1. 使用贪心策略，将高个子优先安排。
2. 利用 k值表示插入位置，结合 `List.add(index, element)` 方法完成插入操作。