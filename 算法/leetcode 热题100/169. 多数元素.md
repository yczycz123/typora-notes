没做过



[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked)



# 自己写的用哈希表做的

```java
class Solution {
    public int majorityElement(int[] nums) {
        int n = nums.length;
        int tar;
        tar = n / 2; // 目标数量，超过一半的个数

        Map<Integer, Integer> map = new HashMap<>(); // 用于存储每个数字出现的次数
        for (int num : nums) {
            // 遍历数组，将每个数字出现的次数记录到 map 中
            map.put(num, map.getOrDefault(num, 0) + 1);
        }

        // 遍历 map，找到出现次数大于 n / 2 的数字（即众数）
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            if (entry.getValue() > tar) {
                return entry.getKey(); // 返回众数
            }
        }

        return 0; // 正常情况不会执行到这里，假设输入一定存在众数
    }
}

```



### ✅ 时间复杂度分析：

- 遍历 `nums` 数组填充 `map`：O(n)
- 遍历 `map` 查找众数：最多 O(n)，但实际会少很多，取决于不同元素的数量
- **总时间复杂度：O(n)**

------

### ✅ 空间复杂度分析：

- 使用了一个 `HashMap` 来统计每个元素的出现次数，最坏情况下 `nums` 中没有重复元素。
- 所以空间复杂度为：**O(n)**（最坏情况下 map 中有 n 个键）









# 空间优化算法



```java
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0; // 当前候选的众数
        int count = 0;     // 候选人的“票数”

        for (int num : nums) {
            if (count == 0) {
                candidate = num; // 当计数为 0 时，更新候选人
            }
            if (candidate == num) {
                count++; // 如果当前数字等于候选人，票数加 1
            } else {
                count--; // 否则票数减 1（视作一个“反对票”）
            }
        }

        return candidate; // 返回最终确定的众数
    }
}

```





## 🧠 Boyer-Moore 投票算法的本质

### 🌟 **假设前提：**

数组中**一定存在一个“众数”**，即某个数的出现次数 > ⌊n/2⌋。

这个假设很关键，因为它保证我们：

- 在不断地“抵消”过程中，最终一定能剩下这个众数。

------

## 🧱 类比理解：一场投票战！

想象你现在是主持一场投票：

- 有一个人可能是“真正的赢家”（众数），其他人都只是“路人”（非众数）。
- 每次你遇到一个人，要么：
  - 和你已有的候选人相同：他站在候选人阵营 → 票数 +1
  - 和你已有的候选人不同：他反对候选人 → 票数 -1

一旦票数为 0，就说明：

> 候选人被“抵消”完了，这时候我们重新选择新的候选人。

但关键点来了：

- **众数的人数一定比所有非众数的总和还多**！
- 所以哪怕你中途换过候选人，最终那个“真正的赢家”一定会在最后时刻胜出！

------

### 🧮 数学上的直觉

设众数为 `M`，出现次数为 `countM > n/2`，
 其他所有数的总出现次数加起来是 `< n/2`。

即使：

- 你开始时没选中 M
- 中途 count 被其他数抵消过
- 最后一定是 M 的力量压倒所有人

**因为：** 抵消过程中每次遇到不同的数都会消耗掉一次“票”，而众数的票是最多的，它一定撑到最后！



## 举例子

### 📌 示例数组：

```

nums = [3, 3, 4, 2, 3, 3, 2, 3]
```

这个数组长度是 8，出现次数 > 8 / 2 = 4 的数就是众数。
 我们可以看到 `3` 出现了 **5 次**，是众数。

------

### 🚀 Boyer-Moore 投票过程：

我们用两个变量：

- `candidate`：当前候选人
- `count`：候选人的“票数”

------

| i    | num  | candidate | count | 操作说明                                          |
| ---- | ---- | --------- | ----- | ------------------------------------------------- |
| 0    | 3    | 3         | 1     | 初始化候选人为 3，count 设为 1                    |
| 1    | 3    | 3         | 2     | 又是 3，count +1                                  |
| 2    | 4    | 3         | 1     | 不是 3，count -1                                  |
| 3    | 2    | 3         | 0     | 不是 3，count -1 → 归零了，说明当前候选人被“抵消” |
| 4    | 3    | 3         | 1     | count 为 0，重新选择候选人为 3                    |
| 5    | 3    | 3         | 2     | 又是 3，count +1                                  |
| 6    | 2    | 3         | 1     | 不是 3，count -1                                  |
| 7    | 3    | 3         | 2     | 是 3，count +1                                    |

------

### ✅ 最终结果：

- `candidate = 3`
- `count = 2`

虽然 count 没有特别大，但它已经是“幸存者”了，因为：

> 所有非众数最终都被它“一一抵消”掉了。

------

### ✨ 为什么这个算法成立？

因为：

- 众数出现 > n/2 次
- 非众数加起来 < n/2 次
- 所以它们全部和众数“对消”，最后还是众数剩下来