### 题目描述

这是 LeetCode 上的 **[868. 二进制间距](https://leetcode-cn.com/problems/binary-gap/solution/by-ac_oier-2sui/)** ，难度为 **简单**。

Tag : 「模拟」



给定一个正整数 $n$，找到并返回 $n$ 的二进制表示中两个 相邻 $1$ 之间的 最长距离 。如果不存在两个相邻的 $1$，返回 $0$ 。

如果只有 $0$ 将两个 $1$ 分隔开（可能不存在 $0$ ），则认为这两个 $1$ 彼此 相邻 。两个 $1$ 之间的距离是它们的二进制表示中位置的绝对差。例如，`"1001"` 中的两个 $1$ 的距离为 $3$ 。

示例 1：
```
输入：n = 22

输出：2

解释：22 的二进制是 "10110" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。
```
示例 2：
```
输入：n = 8

输出：0

解释：8 的二进制是 "1000" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。
```
示例 3：
```
输入：n = 5

输出：2

解释：5 的二进制是 "101" 。
```

提示：
* $1 <= n <= 10^9$

---

### 模拟

根据题意进行模拟即可，遍历 $n$ 的二进制中的每一位 $i$，同时记录上一位 $1$ 的位置 $j$，即可得到所有相邻 $1$ 的间距，所有间距取 $\max$ 即是答案。

代码：
```Java
class Solution {
    public int binaryGap(int n) {
        int ans = 0;
        for (int i = 31, j = -1; i >= 0; i--) {
            if (((n >> i) & 1) == 1) {
                if (j != -1) ans = Math.max(ans, j - i);
                j = i;
            }
        }
        return ans;
    }
}
```
* 时间复杂度：$O(\log{n})$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.868` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

