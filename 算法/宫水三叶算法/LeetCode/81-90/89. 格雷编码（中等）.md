### 题目描述

这是 LeetCode 上的 **[89. 格雷编码](https://leetcode-cn.com/problems/gray-code/solution/gong-shui-san-xie-dui-cheng-xing-gou-zao-9ap1/)** ，难度为 **中等**。

Tag : 「模拟」



$n$ 位格雷码序列 是一个由 $2^n$ 个整数组成的序列，其中：
* 每个整数都在范围 $[0, 2^n - 1]$ 内（含 $0$ 和 $2^n - 1$）
* 第一个整数是 0
* 一个整数在序列中出现 不超过一次
* 每对 相邻 整数的二进制表示 恰好一位不同 ，且
* 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 `n` ，返回任一有效的 `n` 位格雷码序列 。

示例 1：
```
输入：n = 2

输出：[0,1,3,2]

解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同

[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```
示例 2：
```
输入：n = 1

输出：[0,1]
```

提示：
* `1 <= n <= 16`

---

### 对称性构造

根据格雷码的定义，我们需要构造一个合法序列，序列之间每两个数的二进制表示中只有一位不同，同时序列第一位和最后一位对应的二进制也只有一位不同。

我们知道 $k + 1$ 位的格雷码序列是 $k$ 位格雷码序列长度的两倍，利用合法 $k$ 位格雷码序列，我们可以「对称性」地构造出 $k + 1$ 位格雷码。

具体的，假定 $k$ 位格雷码序列长度为 $n$，我们将这 $k$ 位的格雷序列进行翻转，并追加到原有序列的尾部，得到长度为 $2 * n$ 的序列，此时新序列的前后两部分均为合法的格雷码。

考虑如何进行解决衔接点的合法性：我们可以对于序列的后半（翻转而来）的部分中的每个数进行「尾部」追加 $1$ 的操作，确保链接点的两个数只有有一位二进制位不同，同时并不影响前后两半部分的合法性。

而且由于后半部分本身是由前半部分翻转而来，序列中的第一个数和最后一个数原本为同一个值，经过追加 $1$ 的操作之后，首尾两个数的二进制表示只有一位不同，整个序列的合法性得以保证。

代码：
```Java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<>();
        ans.add(0);
        while (n-- > 0) {
            int m = ans.size();
            for (int i = m - 1; i >= 0; i--) {
                ans.set(i, ans.get(i) << 1);
                ans.add(ans.get(i) + 1);
            }
        }
        return ans;
    }
}
```
* 时间复杂度：$O(2^n)$
* 空间复杂度：$O(2^n)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.89` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

