### 题目描述

这是 LeetCode 上的 **[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/shua-chuan-lc-jian-ji-jie-fa-by-ac_oier-69tp/)** ，难度为 **中等**。

Tag : 「模拟」



请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 `myAtoi(string s)` 的算法如下：

* 读入字符串并丢弃无用的前导空格
* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，`"123" -> 123`， `"0032" -> 32`）。如果没有读入数字，则整数为 $0$ 。必要时更改符号（从步骤 $2$ 开始）。
* 如果整数数超过 $32$ 位有符号整数范围 [−$2^{31}$,  $2^{31}$ − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −$2^{31}$ 的整数应该被固定为 −$2^{31}$ ，大于 $2^{31}$ − 1 的整数应该被固定为 $2^{31}$ − 1 。
* 返回整数作为最终结果。


注意：

* 本题中的空白字符只包括空格字符 `' '` 。
* 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。



示例 1：

```
输入：s = "42"

输出：42

解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。

第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```
示例 2：
```
输入：s = "   -42"

输出：-42

解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```
示例 3：
```
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
```
示例 4：
```
输入：s = "words and 987"

输出：0

解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。
```
示例 5：
```
输入：s = "-91283472332"

输出：-2147483648

解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。
```

提示：
* $0 <= s.length <= 200$
* `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成

---
### 朴素解法

这是道模拟题。

一看这题目描述，多少有点做工程项目各种判断的意思了。

但对于这类题目，切忌一上来直接写代码，很容易会陷入各种边界判断。

这时候一个比较推荐的做法是先对要求进行提炼整理：

1. 忽略前导空格
2. 首字符只能是 正号/负号/数字，否则不合法（返回 0）
3. 继续往后匹配字符，直到结尾或不为数字为止（匹配过程中如果出现溢出，根据正负直接返回 `Integer.MAX_VALUE` 或 `Integer.MIN_VALUE`）。

当整理出来具体的逻辑之后，记得再次检查是否有遗漏掉某些边界情况。

确定逻辑之后，代码就好写了。

代码：
```Java
class Solution {
    public int myAtoi(String s) {
        int n = s.length();
        char[] chars = s.toCharArray();
        int idx = 0;       
        
        // 去除前导空格，如果去完前导空格后无字符了，返回 0
        while (idx < n && chars[idx] == ' ') idx++;
        if (idx == n) return 0;

        // 检查第一个字符：可以为正负号/数字
        boolean isNeg = false;
        if (chars[idx] == '-') {
            idx++;
            isNeg = true;
        } else if (chars[idx] == '+') {
            idx++;
        } else if (!Character.isDigit(chars[idx])) {
            return 0;
        } 

        int ans = 0;
        while (idx < n && Character.isDigit(chars[idx])) {
            int cur = chars[idx++] - '0';
            // 和上一题的“【刷穿 LeetCode】7. 整数反转”一样，防止 ans = ans * 10 + cur 溢出
            // 等价变形为 ans > (Integer.MAX_VALUE - cur) / 10 进行预判断
            if (ans > (Integer.MAX_VALUE - cur) / 10) {
                return isNeg ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            ans = ans * 10 + cur;
        }
        return isNeg ? -ans : ans;
    }
}
```
* 时间复杂度：会对整个字符串 `s` 扫描一遍。复杂度为 $O(n)$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.8` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

