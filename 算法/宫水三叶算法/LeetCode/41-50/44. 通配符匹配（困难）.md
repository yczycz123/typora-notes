### 题目描述

这是 LeetCode 上的 **[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/solution/gong-shui-san-xie-xiang-jie-dong-tai-gui-ifyx/)** ，难度为 **困难**。

Tag : 「动态规划」、「序列 DP」




给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

* `'?'` 可以匹配任何单个字符。
* `'*'` 可以匹配任意字符串（包括空字符串）。

两个字符串完全匹配才算匹配成功。

说明:

* `s` 可能为空，且只包含从 `a-z` 的小写字母。
* `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。

示例 1:
```
输入:
s = "aa"
p = "a"

输出: false

解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "*"

输出: true

解释: '*' 可以匹配任意字符串。
```
示例 3:
```
输入:
s = "cb"
p = "?a"

输出: false

解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4:
```
输入:
s = "adceb"
p = "*a*b"

输出: true

解释: 
第一个 '*' 可以匹配空字符串, 
第二个 '*' 可以匹配字符串 "dce".
```
示例 5:
```
输入:
s = "acdcb"
p = "a*c?b"

输出: false
```



---

### 动态规划

这道题与 [10. 正则表达式匹配](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=1&sn=af3517194634dde1652ec72eb5ea9ff2&chksm=fd9ca9fdcaeb20eb1fd7509e3adf8fee6f75d77b8afbd30067ac11a56bd77b5066b0f164eb49&token=840813710&lang=zh_CN#rd) 的分析思路是类似的。

但和第 10 题相比，本题要简单一些。

整理一下题意，对于字符串 `p` 而言，有三种字符：

* 普通字符：需要和 `s` 中同一位置的字符完全匹配

* `'?'`：能够匹配 `s` 中同一位置的任意字符

* `'*'`：能够匹配任意字符串

所以本题关键是分析当出现 `'*'` 这种字符时，是匹配 0 个字符、还是 1 个字符、还是 2 个字符 ...

本题可以使用动态规划进行求解：

* 状态定义：`f(i,j)` 代表考虑 `s` 中以 `i` 为结尾的子串和 `p` 中的 `j` 为结尾的子串是否匹配。最终我们要求的结果为 `f[n][m]` 。

* 状态转移：也就是我们要考虑 `f(i,j)` 如何求得，前面说到了 `p` 有三种字符，所以这里的状态转移也要分三种情况讨论：
  
  1. `p[j]` 为普通字符：匹配的条件是前面的字符匹配，同时 `s` 中的第 `i` 个字符和 `p` 中的第 `j` 位相同。 
  
      即 `f(i,j) = f(i - 1, j - 1) && s[i] == p[j]` 。
  
  2. `p[j]` 为 `'?'`：匹配的条件是前面的字符匹配，`s` 中的第 `i` 个字符可以是任意字符。
  
      即 `f(i,j) = f(i - 1, j - 1) && p[j] == '?'`。
  
  3. `p[j]` 为 `'*'`：可匹配任意长度的字符，可以匹配 0 个字符、匹配 1 个字符、匹配 2 个字符
  
      3.1. 当匹配为 0 个：`f(i,j) = f(i, j - 1)`
  
      3.2. 当匹配为 1 个：`f(i,j) = f(i - 1, j - 1)`
  
      3.3. 当匹配为 2 个：`f(i,j) = f(i - 2, j - 1)`
  
      ...
  
      3.k. 当匹配为 k 个：`f(i,j) = f(i - k, j - 1)`
  

因此对于 `p[j] = '*'` 的情况，想要 `f(i, j) = true`，只需要其中一种情况为 `true` 即可。

也就是状态之间是「或」的关系：
$$
f[i][j] = f[i][j - 1] || f[i - 1][j - 1] || ... || f[i - k][j - 1] (i >= k)
$$

这意味着我们要对 `k` 种情况进行枚举检查吗？

其实并不用，对于这类问题，我们通常可以通过「代数」进简化，将 `i - 1` 代入上述的式子：

$$
f[i - 1][j] = f[i - 1][j - 1] || f[i - 2][j - 1] || ... || f[i - k][j - 1] (i >= k)
$$

可以发现，`f[i - 1][j]` 与 `f[i][j]` 中的 `f[i][j - 1]` 开始的后半部分是一样的。

因此有：

$$
f[i][j] = f[i][j - 1] || f[i - 1][j] (i >= 1)
$$

*PS. 其实类似的推导，我在 [10. 正则表达式匹配](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=1&sn=af3517194634dde1652ec72eb5ea9ff2&chksm=fd9ca9fdcaeb20eb1fd7509e3adf8fee6f75d77b8afbd30067ac11a56bd77b5066b0f164eb49&token=840813710&lang=zh_CN#rd) 也做过，第 10 题的推导过程还涉及等差概念，我十分推荐你去回顾一下。如果你能搞懂第 10 题整个过程，这题其实就是小 Case。*

编码细节：

1. 通过上述的推导过程，你会发现设计不少的「回退检查」操作（即遍历到 `i` 位，要回头检查 `i - 1` 等），因此我们可以将「哨兵技巧」应用到本题，往两个字符串的头部插入哨兵
2. 对于 `p[j] = '?'` 和 `p[j] = 普通字符` 的情况，想要为 `true`，其实有共同的条件 `f[i - 1][j - 1] == true`，因此可以合到一起来做

Java 代码：
```Java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length(), m = p.length();
        // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去
        s = " " + s; p = " " + p;
        char[] ss = s.toCharArray(), pp = p.toCharArray();
        // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (pp[j] == '*') {
                    f[i][j] = f[i][j - 1] || (i - 1 >= 0 && f[i - 1][j]);
                } else {
                    f[i][j] = i - 1 >= 0 && f[i - 1][j - 1] && (ss[i] == pp[j] || pp[j] == '?');
                }
            }
        }
        return f[n][m];
    }
}
```
C++ 代码：
```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.length(), m = p.length();
        s = " " + s; p = " " + p;
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1, false));
        f[0][0] = true;
        for (int i = 0; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (p[j] == '*') {
                    f[i][j] = f[i][j - 1] || (i - 1 >= 0 && f[i - 1][j]);
                } else {
                    f[i][j] = i - 1 >= 0 && f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '?');
                }
            }
        }
        return f[n][m];
    }
};
```
Python 代码：
```Python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        n, m = len(s), len(p)
        s = " " + s
        p = " " + p
        f = [[False] * (m + 1) for _ in range(n + 1)]
        f[0][0] = True
        for i in range(n + 1):
            for j in range(1, m + 1):
                if p[j] == '*':
                    f[i][j] = f[i][j - 1] or (i - 1 >= 0 and f[i - 1][j])
                else:
                    f[i][j] = i - 1 >= 0 and f[i - 1][j - 1] and (s[i] == p[j] or p[j] == '?')
        return f[n][m]
```
TypeScript 代码：
```TypeScript
function isMatch(s: string, p: string): boolean {
    const n = s.length, m = p.length;
    s = " " + s;
    p = " " + p;
    const f = new Array(n + 1).fill(false).map(() => new Array(m + 1).fill(false));
    f[0][0] = true;
    for (let i = 0; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (p[j] === '*') {
                f[i][j] = f[i][j - 1] || (i - 1 >= 0 && f[i - 1][j]);
            } else {
                f[i][j] = i - 1 >= 0 && f[i - 1][j - 1] && (s[i] === p[j] || p[j] === '?');
            }
        }
    }
    return f[n][m];
};
```
* 时间复杂度：`n` 表示 `s` 的长度，`m` 表示 `p` 的长度，总共 $n \times m$ 个状态。复杂度为 $O(n \times m)$
* 空间复杂度：使用了二维数组记录结果。复杂度为 $O(n \times m)$

**再次强调，动态规划本质上是枚举（不重复的暴力枚举），因此其复杂度很好分析，有多少个状态就要被计算多少次，复杂度就为多少。**

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.44` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

