### 题目描述

这是 LeetCode 上的 **[剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-wei-shu-j-g9w6/)** ，难度为 **简单**。

Tag : 「位运算」、「分治」

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```
示例 2：
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
示例 3：
```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

提示：
* 输入必须是长度为 32 的 二进制串 。

---

### 「位数检查」解法

一个朴素的做法是，对 `int` 的每一位进行检查，并统计 $1$ 的个数。

![image.png](https://pic.leetcode-cn.com/1616375441-WGCssd-image.png)

代码：
```Java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans += ((n >> i) & 1);
        }
        return ans;
    }
}
```
* 时间复杂度：$O(k)$，$k$ 为 `int` 的位数，固定为 $32$ 位
* 空间复杂度：$O(1)$

***

### 「右移统计」解法

对于方法一，即使 $n$ 的高位均为是 $0$，我们也会对此进行循环检查。

因此另外一个做法是：通过 `n & 1` 来统计当前 $n$ 的最低位是否为 $1$，同时每次直接对 $n$ 进行右移并高位补 0。

当 $n = 0$ 代表，我们已经将所有的 $1$ 统计完成。

这样的做法，可以确保只会循环到最高位的 $1$。

![image.png](https://pic.leetcode-cn.com/1616375636-fXCFNF-image.png)

代码：
```Java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        while (n != 0) {
            ans += (n & 1);
            n >>>= 1;
        }
        return ans;
    }
}
```
* 时间复杂度：$O(k)$，$k$ 为 `int` 的位数，固定为 $32$ 位，最坏情况 $n$ 的二进制表示全是 $1$
* 空间复杂度：$O(1)$

---

### 「lowbit」解法

对于方法二，如果最高位 $1$ 和 最低位 $1$ 之间全是 $0$，我们仍然会诸次右移，直到处理到最高位的 $1$ 为止。

那么是否有办法，只对位数为 $1$ 的二进制位进行处理呢？

使用 `lowbit` 即可做到，`lowbit` 会在 $O(1)$ 复杂度内返回二进制表示中最低位 $1$ 所表示的数值。

例如 $(0000...111100)_2$ 传入 `lowbit` 返回 $(0000...000100)_2$；$(0000...00011)_2$ 传入 `lowbit` 返回 $(0000...00001)_2$ ...

![image.png](https://pic.leetcode-cn.com/1616375636-fXCFNF-image.png)

代码：
```Java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        for (int i = n; i != 0; i -= lowbit(i)) ans++;
        return ans;
    }
    int lowbit(int x) {
        return x & -x;
    }
}
```
* 时间复杂度：$O(k)$，$k$ 为 `int` 的位数，固定为 $32$ 位，最坏情况 $n$ 的二进制表示全是 $1$
* 空间复杂度：$O(1)$

---

### 「分组统计」解法

以上三种解法都是 $O(k)$ 的，事实上我们可以通过分组统计的方式，做到比 $O(k)$ 更低的复杂度。

![image.png](https://pic.leetcode-cn.com/1616378128-yBWadF-image.png)

代码：
```Java
public class Solution {
    public int hammingWeight(int n) {
        n = (n & 0x55555555) + ((n >>> 1)  & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2)  & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >>> 4)  & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >>> 8)  & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
        return n;
    }
}
```
* 时间复杂度：$O(\log{k})$，$k$ 为 `int` 的位数，固定为 $32$ 位
* 空间复杂度：$O(1)$


PS. 对于该解法，如果大家学有余力的话，还是建议大家在纸上模拟一下这个过程。如果不想深入，也可以当成模板背过（写法非常固定），但通常如果不是写底层框架，你几乎不会遇到需要一个 $O(\log{k})$ 解法的情况。

而且这个做法的最大作用，不是处理 `int`，而是处理更大位数的情况，在长度只有 $32$ 位的 `int` 的情况下，该做法不一定就比循环要快（该做法会产生多个的中间结果，导致赋值发生多次，而且由于指令之间存在对 $n$ 数值依赖，可能不会被优化为并行指令），这个道理和对于排序元素少的情况下，我们会选择「选择排序」而不是「归并排序」是一样的。

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `剑指 Offer 15` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

