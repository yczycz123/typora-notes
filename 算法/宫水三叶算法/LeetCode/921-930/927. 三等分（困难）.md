### 题目描述

这是 LeetCode 上的 **[927. 三等分](https://leetcode.cn/problems/three-equal-parts/solution/by-ac_oier-9i2s/)** ，难度为 **困难**。

Tag : 「模拟」



给定一个由 `0` 和 `1` 组成的数组 `arr`，将数组分成  `3` 个非空的部分 ，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 `[i, j]`，其中 `i+1 < j`，这样一来：

* `arr[0], arr[1], ..., arr[i]` 为第一部分；
* `arr[i + 1], arr[i + 2], ..., arr[j - 1]` 为第二部分；
* `arr[j], arr[j + 1], ..., arr[arr.length - 1]` 为第三部分。
* 这三个部分所表示的二进制值相等。

如果无法做到，就返回 `[-1, -1]`。

注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，`[1,1,0]` 表示十进制中的 `6`，而不会是 `3`。此外，前导零也是被允许的，所以 `[0,1,1]` 和 `[1,1]` 表示相同的值。

示例 1：
```
输入：arr = [1,0,1,0,1]

输出：[0,3]
```
示例 2：
```
输入：arr = [1,1,0,1,1]

输出：[-1,-1]
```
示例 3:
```
输入：arr = [1,1,0,0,1]

输出：[0,2]
```

提示：
* $3 <= arr.length <= 3 \times 10^4$
* `arr[i]` 是 `0` 或 `1`

---

### 模拟

心情不好，写的代码也不好。

就大概讲讲啥意思吧：

1. 先统计 `1` 的个数 `cnt`，若 `cnt = 0` 代表能够任意划分，直接返回 `[0, 2]`；
2. 若 `cnt` 不为 $3$ 的倍数，必然不能正常划分，返回无解 `[-1, -1]`，否则可知三段中必然每一段 `1` 的数量均为 $t = \frac{cnt}{3}$ 个；
3. 最后检查「三段中 `1` 的间隔位是否相同，后缀 `0` 个数是否相同」即可：
    1. 创建二维数组 `ins` 记录三段中，相邻 `1` 之间的间隔情况，若存在间隔 `1` 不同，返回无解 `[-1, -1]`；
    2. 预处理四个变量 `l1`、`l2`、`r1` 和 `r2`，分别代表能够划分出最左边 `t` 个 `1` 的左右端点，以及能够划分出最右边 `t` 个 `1` 的左右端点，同时统计最后一段的后缀 `0` 的数量 `d`，配合四个变量来检查能否划分出具有 `d` 个后缀 `0` 的前两段。

代码：
```Java
class Solution {
    public int[] threeEqualParts(int[] arr) {
        int[] fail = new int[]{-1, -1};
        // 检查总数
        int n = arr.length, cnt = 0;
        for (int i = 0; i < n; i++) cnt += arr[i];
        if (cnt == 0) return new int[]{0, 2};
        if (cnt % 3 != 0) return fail;
        // 检查间隔相对位
        int t = cnt / 3;
        int[][] ins = new int[3][t];
        for (int i = 0, j = -1, k = 0, p = 0, idx = 0; i < n; i++) {
            if (arr[i] == 0) continue;
            if (j != -1) ins[p][idx++] = i - j;
            if (++k == t) {
                j = -1; k = 0; p++; idx = 0;
            } else {
                j = i;
            }
        }
        for (int i = 0; i < t; i++) {
            if (ins[0][i] == ins[1][i] && ins[0][i] == ins[2][i] && ins[1][i] == ins[2][i]) continue;
            return fail;
        }
        // 构造答案（l1 和 l2 分别为能够划分出最左边 t 个 1 的 左右端点；r1 和 r2 分别为能够划分出最右边 t 个 1 的左右端点）
        int l1 = -1, l2 = -1, r1 = -1, r2 = -1;
        for (int i = 0, k = 0; i < n; i++) {
            k += arr[i];
            if (k == t) {
                if (l1 == -1) l1 = i;
            } else if (k == t + 1) {
                l2 = i - 1;
                break;
            }
        }
        for (int i = n - 1, k = 0; i >= 0; i--) {
            k += arr[i];
            if (k == t) {
                if (r2 == -1) r2 = i;
            } else if (k == t + 1) {
                r1 = i + 1;
                break;
            }
        }
        int d = 0; // d 为最右边一段的后缀 0 的数量
        for (int i = n - 1; i >= 0; i--) {
            if (arr[i] == 1) break;
            d++;
        }
        if (l1 + d > l2 || r1 + d > r2) return fail;
        return new int[]{l1 + d, r1 + d};
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(n)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.927` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

