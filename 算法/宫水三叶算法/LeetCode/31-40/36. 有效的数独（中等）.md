### 题目描述

这是 LeetCode 上的 **[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/)** ，难度为 **中等**。

Tag : 「哈希表」、「数组」、「位运算」、「数独问题」



请你判断一个 `9 x 9` 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3 x 3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

注意：
* 一个有效的数独（部分已被填充）不一定是可解的。
* 只需要根据以上规则，验证已经填入的数字是否有效即可。


示例 1：
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：true
```
示例 2：
```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：false

解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

提示：
* $board.length == 9$
* $board[i].length == 9$
* `board[i][j]` 是一位数字或者 `'.'`

---

### 哈希表

由于只要我们判断是否为有效的数独。

所以我们只需要对 `board` 中出现的数进行判断，如果 `board` 中有数违反了数独的规则，返回 `false`，否则返回 `true`。

直观上，我们很容易想到使用 **哈希表** 来记录某行/某列/某个小方块出现过哪些数字，来帮助我们判断是否符合「有效数独」的定义。

这道题唯一的难点可能是在于如何确定某个数落在哪个小方块中，我们可以去小方块进行编号：

![xx1.png](https://pic.leetcode-cn.com/1611905609-HXFmUe-xx1.png)

然后推导出小方块编号和行列的关系为： $idx = \left \lfloor i / 3 \right \rfloor * 3 + \left \lfloor j / 3 \right \rfloor$。

代码：
```Java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        Map<Integer, Set<Integer>> row  = new HashMap<>(), col = new HashMap<>(), area = new HashMap<>();
        for (int i = 0; i < 9; i++) {
            row.put(i, new HashSet<>());
            col.put(i, new HashSet<>());
            area.put(i, new HashSet<>());
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') continue;
                int u = c - '0';
                int idx = i / 3 * 3 + j / 3;
                if (row.get(i).contains(u) || col.get(j).contains(u) || area.get(idx).contains(u)) return false;
                row.get(i).add(u);
                col.get(j).add(u);
                area.get(idx).add(u);
            }
        }
        return true;
    }
}
```
* 时间复杂度：在固定 $9 \times 9$ 的问题里，计算量不随数据变化而变化。复杂度为 $O(1)$
* 空间复杂度：在固定 $9 \times 9$ 的问题里，存储空间不随数据变化而变化。复杂度为 $O(1)$

---

### 数组

大多数的哈希表计数问题，都能转换为使用数组解决。

虽然时间复杂度一样，但哈希表的更新和查询复杂度为均摊 $O(1)$，而定长数组的的更新和查询复杂度则是严格 $O(1)$。

因此从执行效率上来说，数组要比哈希表快上不少。

代码：
```Java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] row = new boolean[10][10], col = new boolean[10][10], area = new boolean[10][10];        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                int c = board[i][j];
                if (c == '.') continue;
                int u = c - '0';
                int idx = i / 3 * 3 + j / 3;
                if (row[i][u] || col[j][u] || area[idx][u]) return false;
                row[i][u] = col[j][u] = area[idx][u] = true;
            }
        }
        return true;
    }
}
```
* 时间复杂度：在固定 $9*9$ 的问题里，计算量不随数据变化而变化。复杂度为 $O(1)$
* 空间复杂度：在固定 $9*9$ 的问题里，存储空间不随数据变化而变化。复杂度为 $O(1)$

---

### 位运算

更进一步，我们可以使用一个 $int$ 来记录 某行/某列/某个小方块 的数值填入情况：使用从低位开始的 $[1, 9]$ 位来记录该数值是否已被填入。

例如 $(... 111000111 .)_2$ 代表数值 $[1, 3]$ 和 $[7, 9]$ 均被填入。

代码：
```Java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[] row = new int[10], col = new int[10], area = new int[10];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') continue;
                int u = c - '0';
                int idx = i / 3 * 3 + j / 3;
                if ((((row[i] >> u) & 1) == 1) || (((col[j] >> u) & 1) == 1) || (((area[idx] >> u) & 1) == 1)) return false;
                row[i] |= (1 << u);
                col[j] |= (1 << u);
                area[idx] |= (1 << u);
            }
        }
        return true;
    }
}
```
* 时间复杂度：在固定 $9 \times 9$ 的问题里，计算量不随数据变化而变化。复杂度为 $O(1)$
* 空间复杂度：在固定 $9 \times 9$ 的问题里，存储空间不随数据变化而变化。复杂度为 $O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.36` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

