### 题目描述

这是 LeetCode 上的 **[2170. 使数组变成交替数组的最少操作数](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/solution/gong-shui-san-xie-jian-dan-ji-shu-lei-ta-0eo4/)** ，难度为 **中等**。

Tag : 「贪心」



给你一个下标从 $0$ 开始的数组 $nums$ ，该数组由 $n$ 个正整数组成。

如果满足下述条件，则数组 $nums$ 是一个 交替数组 ：

* $nums[i - 2] == nums[i]$ ，其中 $2 <= i <= n - 1$ 。
* $nums[i - 1] != nums[i]$ ，其中 $1 <= i <= n - 1$ 。

在一步 操作 中，你可以选择下标 $i$ 并将 $nums[i]$ 更改 为 任一 正整数。

返回使数组变成交替数组的 最少操作数 。

示例 1：
```
输入：nums = [3,1,3,2,4,3]

输出：3

解释：
使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。
在这种情况下，操作数为 3 。
可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。
```
示例 2：
```
输入：nums = [1,2,2,2,2]

输出：2

解释：
使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].
在这种情况下，操作数为 2 。
注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。
```

提示：
* $1 <= nums.length <= 10^5$
* $1 <= nums[i] <= 10^5$

---

### 贪心

根据「交替数组」的定义，我们可以将数组根据下标奇偶性分成两个序列，最终目的是：**使用最少的修改次数，使得「两个序列均成为公差为 $0$ 等差数列」，同时「两序列的首项不相等」。**

要用最少次数将一个序列修改为公差为 $0$ 等差数列，等价于修改最少的数字，等价于保留最多的数字，容易想到将序列中的其他「非众数」修改为「众数」（若有多个众数，取任一）。

而单纯对两个序列执行上述逻辑，并不能确保最终得到的是「交替数组」，即未必满足「两序列的首项不相等」的要求。

因此我们可以对 $nums$ 进行扫描，分别统计「偶数下标序列」和「奇数下标序列」的最大值（众数）和次大值（**注意是非严格的次大值，即为「其他众数」或者「出现次数比众数小的数」**），使用 `a` 和 `b` 代指「偶数下标序列」的最大值和次大值，使用 `c` 和 `d` 代指「奇数下标序列」的最大值和次大值。同时使用 `m1` 和 `m2` 分别统计「偶数下标序列」和「奇数下标序列」中某个数的出现次数。

根据两序列的最大值是否冲突进行分情况讨论：

* 若两序列的最大值不冲突（$a\neq c$）：那么两序列都可以取得最小修改次数（保留最大值），整体的最小修改次数为 $n - m1[a] - m2[c]$ ；
* 若两序列的最大值冲突（$a\ = c$）：那么仅一序列可以取得最小修改次数（保留最大值），另一序列只能取得“次小”的修改次数（保留次大值），此时整体的最小修改次数为 $n - \max(m1[a] + m2[d], m1[b] + m2[c])$。

代码：
```Java
class Solution {
    static int N = 100010;
    static int[] m1 = new int[N], m2 = new int[N];
    public int minimumOperations(int[] nums) {
        int n = nums.length;
        Arrays.fill(m1, 0);
        Arrays.fill(m2, 0);
        int a = 0, b = 0, c = 0, d = 0;
        for (int i = 0; i < n; i++) {
            int t = nums[i];
            if (i % 2 == 0) {
                m1[t]++;
                if (a == 0 || m1[t] > m1[a]) {
                    b = a; a = t;
                } else if (t != a && (b == 0 || m1[t] > m1[b])) {
                    b = t;
                }
            } else {
                m2[t]++;
                if (c == 0 || m2[t] > m2[c]) {
                    d = c; c = t;
                } else if (t != c && (d == 0 || m2[t] > m2[d])) {
                    d = t;
                }
            }
        }
        if (a != c) return n - m1[a] - m2[c];
        else return n - Math.max(m1[a] + m2[d], m1[b] + m2[c]);
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(C)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.2170` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

