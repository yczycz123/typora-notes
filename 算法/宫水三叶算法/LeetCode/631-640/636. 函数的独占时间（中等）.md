### 题目描述

这是 LeetCode 上的 **[636. 函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/solution/by-ac_oier-z3ed/)** ，难度为 **中等**。

Tag : 「模拟」、「栈」



有一个单线程 `CPU` 正在运行一个含有 `n` 道函数的程序。

每道函数都有一个位于  `0` 和 `n-1` 之间的唯一标识符。

函数调用存储在一个调用栈上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是当前正在执行的函数。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。

给你一个由日志组成的列表 `logs` ，其中 `logs[i]` 表示第 `i` 条日志消息，该消息是一个按 `"{function_id}:{"start" | "end"}:{timestamp}"` 进行格式化的字符串。

例如，`"0:start:3"` 意味着标识符为 `0` 的函数调用在时间戳 `3` 的 起始开始执行 ；而 `"1:end:2"` 意味着标识符为 `1` 的函数调用在时间戳 `2` 的末尾结束执行。

注意，函数可以调用多次，可能存在递归调用 。

函数的「独占时间」定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。

例如，如果一个函数被调用两次，一次调用执行 `2` 单位时间，另一次调用执行 `1` 单位时间，那么该函数的独占时间为 `2 + 1 = 3` 。

以数组形式返回每个函数的独占时间，其中第 `i` 个下标对应的值表示标识符 `i` 的函数的独占时间。

示例 1：
![](https://assets.leetcode.com/uploads/2019/04/05/diag1b.png)
```
输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]

输出：[3,4]

解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 
函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 
函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 
所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 
```
示例 2：
```
输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]

输出：[8]

解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻再次调用它自身。
函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。
所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。
```
示例 3：
```
输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]

输出：[7,1]

解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻调用函数 1 。
函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。
所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 
```
示例 4：
```
输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]

输出：[8,1]
```
示例 5：
```
输入：n = 1, logs = ["0:start:0","0:end:0"]

输出：[1]
```

提示：
* $1 <= n <= 100$
* $1 <= logs.length <= 500$
* $0 <= function_id < n$
* $0 <= timestamp <= 10^9$
* 两个开始事件不会在同一时间戳发生
* 两个结束事件不会在同一时间戳发生
* 每道函数都有一个对应 `"start"` 日志的 `"end"` 日志

---

### 模拟

我们使用「栈」来模拟执行过程：当一个函数被调用（`op = start`）时，压入栈内，当函数调用完成（`op = end`）时，从栈顶弹出（此时栈顶元素必然是该结束函数的入栈记录），使用变量 `cur` 记录当前时间。

从前往后处理所有的 $log[i]$，根据 $log[i]$ 是属于函数调用还是函数结束进行分情况讨论：

* 当 $log[i]$ 为函数调用：此时从该函数的调用发起时间 `ts` 到上一次记录的当前时间，都是前一函数的执行时间，因此可以将 `ts - cur` 累加到栈帧中的前一函数。即若栈不为空，则将该时间累加到栈顶对应的函数上，然后将 $log[i]$ 入栈，同时更新当前时间；
* 当 $log[i]$ 为函数结束：此时栈顶元素必然是该函数的调用记录，此时 $log[i]$ 的结束时间与上一次记录的当前时间的时长 `ts - cur + 1`，必然是该函数的执行时间，将其累加到当前函数中，并更新当前时间。

Java 代码：
```Java
class Solution {
    public int[] exclusiveTime(int n, List<String> logs) {
        int[] ans = new int[n];
        Deque<Integer> d = new ArrayDeque<>();
        int cur = -1;
        for (String log : logs) {
            String[] ss = log.split(":");
            int idx = Integer.parseInt(ss[0]), ts = Integer.parseInt(ss[2]);
            if (ss[1].equals("start")) {
                if (!d.isEmpty()) ans[d.peekLast()] += ts - cur;
                d.addLast(idx);
                cur = ts;
            } else {
                int func = d.pollLast();
                ans[func] += ts - cur + 1;
                cur = ts + 1;
            }
        }
        return ans;
    }
}
```
C++ 代码：
```C++
class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
        vector<int> ans(n, 0);
        stack<int> s;
        int cur = -1;
        for (auto log : logs) {
            istringstream ss(log);
            string buf;
            vector<string> tokens;
            while (getline(ss, buf, ':')) {
                tokens.push_back(buf);
            }
            int idx = stoi(tokens[0]), ts = stoi(tokens[2]);
            if (tokens[1] == "start") {
                if (!s.empty()) ans[s.top()] += ts - cur;
                s.push(idx);
                cur = ts;
            } else {
                ans[s.top()] += ts - cur + 1;
                s.pop();
                cur = ts + 1;
            }
        }
        return ans;
    }
};
```
Python 代码：
```Python
class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        ans = [0] * n
        s = []
        cur = -1
        for log in logs:
            ss = log.split(':')
            idx, ts = int(ss[0]), int(ss[2])
            if ss[1] == "start":
                if s: ans[s[-1]] += ts - cur
                s.append(idx)
                cur = ts
            else:
                ans[s.pop()] += ts - cur + 1
                cur = ts + 1
        return ans
```
TypeScript 代码：
```TypeScript
function exclusiveTime(n: number, logs: string[]): number[] {
    const ans = new Array<number>(n).fill(0)
    const stk = new Array<number>()
    let he = 0, ta = 0, cur = -1
    for (let log of logs) {
        const ss = log.split(":")
        const idx = Number(ss[0]), ts = Number(ss[2])
        if (ss[1] == "start") {
            if (he < ta) ans[stk[ta - 1]] += ts - cur
            stk[ta++] = idx
            cur = ts
        } else {
            const func = stk[--ta]
            ans[func] += ts - cur + 1
            cur = ts + 1
        }
    }
    return ans
};
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(n)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.636` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

