### 题目描述

这是 LeetCode 上的 **[1588. 所有奇数长度子数组的和](https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-18jq3/)** ，难度为 **简单**。

Tag : 「前缀和」、「数学」



给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 `arr` 中 所有奇数长度子数组的和 。

示例 1：
```
输入：arr = [1,4,2,5,3]

输出：58

解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```
示例 2：
```
输入：arr = [1,2]

输出：3

解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
```
示例 3：
```
输入：arr = [10,11,12]

输出：66
```

提示：
* 1 <= arr.length <= 100
* 1 <= arr[i] <= 1000

---

### 前缀和 

枚举所有长度为奇数的子数组，我们可以通过「枚举长度 - 枚举左端点，并计算右端点」的两层循环来做。

而对于区间 $[l, r]$ 的和问题，可以直接再加一层循环来做，这样复杂度来到了 $O(n^3)$，但本题数据范围只有 $100$，也是可以过的。

对于此类区间求和问题，我们应当想到使用「前缀和」进行优化：使用 $O(n)$ 的复杂度预处理出前缀和数组，每次查询 $[l, r]$ 区间和可以在 $O(1)$ 返回。

代码：
```Java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int n = arr.length;
        int[] sum = new int[n + 1];
        for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + arr[i - 1];
        int ans = 0;
        for (int len = 1; len <= n; len += 2) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                ans += sum[r + 1] - sum[l];
            }
        }
        return ans;
    }
}
```
* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(n)$

----

### 数学

事实上，我们可以统计任意值 $arr[i]$ 在奇数子数组的出现次数。

对于原数组的任意位置 $i$ 而言，其左边共有 $i$ 个数，右边共有 $n - i - 1$ 个数。

**$arr[i]$ 作为某个奇数子数组的成员的充要条件为：其所在奇数子数组左右两边元素个数奇偶性相同。**

于是问题转换为如何求得「$arr[i]$ 在原数组中两边连续一段元素个为奇数的方案数」和「$arr[i]$ 在原数组两边连续一段元素个数为偶数的方案数」。

由于我们已经知道 $arr[i]$ 左边共有 $i$ 个数，右边共有 $n - i - 1$ 个数，因此可以算得组合数：

* 位置 $i$ 左边奇数个数的方案数为 $(i + 1) / 2$，右边奇数个数的方案数为 $(n - i) / 2$；
* 位置 $i$ 左边偶数（非零）个数的方案数为 $i / 2$，右边偶数（非零）个数的方案数为 $(n - i - 1) / 2$；
    * 考虑左右两边不选也属于合法的偶数个数方案数，因此在上述分析基础上对偶数方案数自增 $1$。

至此，我们得到了位置 $i$ 左右奇数和偶数的方案数个数，根据「如果 $arr[i]$ 位于奇数子数组中，其左右两边元素个数奇偶性相同」以及「乘法原理」，我们知道 $arr[i]$ 同出现在多少个奇数子数组中，再乘上 $arr[i]$ 即是 $arr[i]$ 对答案的贡献。

代码：
```Java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int n = arr.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l1 = (i + 1) / 2, r1 = (n - i) / 2; // 奇数
            int l2 = i / 2, r2 = (n - i - 1) / 2; // 偶数
            l2++; r2++;
            ans += (l1 * r1 + l2 * r2) * arr[i];
        }
        return ans;
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.1588` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

