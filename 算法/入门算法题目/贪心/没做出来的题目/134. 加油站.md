

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/)





[贪心算法，得这么加油才能跑完全程！LeetCode ：134.加油站_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jA411r7WX/?vd_source=96c1635797a0d7626fb60e973a29da38)





```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int totalSum = 0;  //记录全局油量差
        int curSum = 0;  //记录当前油量差
        int startIndex = 0;  //记录开始的站点,默认为0
        for (int i = 0; i < gas.length; i++) {
            totalSum += gas[i] - cost[i];
            curSum += gas[i] - cost[i];
            if (curSum < 0) { //例如从0-3站点计算得到的curSum<0,那么0-3站点之间的任意一个站点都不能走完一圈，只能从4开始尝试
                startIndex = i + 1;
                curSum = 0;  //清空当前油量差
            }
        }
        if (totalSum < 0) {  //如果全局油量差<0，说明任何站点开始都不能走一圈
            return -1;
        } else {
            return startIndex;
        }
    }
}
```

**例如从0-3站点计算得到的curSum<0,那么0-3站点之间的任意一个站点都不能走完一圈，只能从4开始尝试**

对于上面这个假设可以这样反证，假如中间存在一个2站点满足条件，那么2-3的curSum 一定大于0，我们又已知了0-3的curSum 一定小于0，那么0-2的curSum 一定小于0，那么我们可以发现，这样2就会成为我们想要的答案。

[代码随想录](https://www.programmercarl.com/0134.加油站.html#思路)这里也给出了详细解释





这段代码实现了通过贪心算法解决 **“加油站”** 问题，以下是详细解析：

------

# **代码逻辑详解**

#### **变量的意义**

1. totalSum：记录整个环路的 

   总油量盈余（gas - cost 的累加）。

   如果 `totalSum < 0`，说明从任何站点出发都无法完成环路，直接返回 `-1`。

2. ```
   curSum
   ```

   ：记录当前从某个站点开始的油量盈余。

   - 如果 `curSum < 0`，表示从当前起点开始无法到达当前位置，需要从下一个站点重新开始计算。

3. ```
   startIndex
   ```

   ：记录可能的起点。

   - 如果 `curSum < 0`，说明当前起点不能作为解，把起点更新为 `i + 1`。

------

#### **遍历逻辑**

1. 遍历

   ```
   gas
   ```

    和 

   ```
   cost
   ```

    数组：

   - 逐站点累加当前站点的油量盈余 `gas[i] - cost[i]`。
   - 更新 `totalSum` 和 `curSum`。

2. 如果 

   ```
   curSum < 0
   ```

   ：

   - 当前站点无法作为环路起点，更新起点为下一站点。
   - 将 `curSum` 重置为 0，重新开始累积。

------

### **代码流程**

以示例输入为例进行解析。

#### 示例 1：

```
int[] gas = {1, 2, 3, 4, 5};
int[] cost = {3, 4, 5, 1, 2};
```

1. **初始化**：
   - `totalSum = 0`
   - `curSum = 0`
   - `startIndex = 0`
2. **遍历数组**：

| i    | gas[i] | cost[i] | `gas[i] - cost[i]` | `totalSum` | `curSum` | `startIndex` |
| ---- | ------ | ------- | ------------------ | ---------- | -------- | ------------ |
| 0    | 1      | 3       | -2                 | -2         | -2       | 1            |
| 1    | 2      | 4       | -2                 | -4         | -2       | 2            |
| 2    | 3      | 5       | -2                 | -6         | -2       | 3            |
| 3    | 4      | 1       | +3                 | -3         | +3       | 3            |
| 4    | 5      | 2       | +3                 | 0          | +6       | 3            |

- 遍历结束后，`totalSum = 0`，表示总油量盈余大于等于总消耗，可以完成环路。
- 返回 `startIndex = 3`。

------

#### 示例 2：

```
int[] gas = {2, 3, 4};
int[] cost = {3, 4, 3};
```

1. **初始化**：
   - `totalSum = 0`
   - `curSum = 0`
   - `startIndex = 0`
2. **遍历数组**：

| i    | gas[i] | cost[i] | `gas[i] - cost[i]` | `totalSum` | `curSum` | `startIndex` |
| ---- | ------ | ------- | ------------------ | ---------- | -------- | ------------ |
| 0    | 2      | 3       | -1                 | -1         | -1       | 1            |
| 1    | 3      | 4       | -1                 | -2         | -1       | 2            |
| 2    | 4      | 3       | +1                 | -1         | +1       | 2            |

- 遍历结束后，`totalSum = -1`，表示总油量小于总消耗，返回 `-1`。

------

### **时间复杂度**

- 遍历数组一次，时间复杂度为 **O(n)**。
- 空间复杂度为 **O(1)**，仅使用了几个辅助变量。

------

### **总结**

- 关键点是通过贪心策略，只需一次遍历就能确定结果。
- `totalSum` 用于全局判断是否有解。
- `curSum` 用于局部判断当前起点是否有效，一旦无效就从下一个站点重新开始。







# **为什么不会返回 `gas.length`？**

让我们详细分析：

### **核心逻辑：**

```
if (curSum < 0) {
    startIndex = i + 1;
    curSum = 0;  // 清空当前油量差
}
```

- 当 `curSum < 0` 时，说明以当前 `startIndex` 为起点无法完成循环，所以需要尝试从下一个加油站（`i + 1`）重新开始。
- **注意**：循环条件是 `for (int i = 0; i < gas.length; i++)`，因此 `i + 1` 的最大值是 `gas.length`。
- 但 `startIndex` 只是用于记录下一个可能的起点，在最终的返回结果中，**程序会确保返回的是一个有效的加油站索引**。

------

### **最终结果的来源**

```
if (totalSum < 0) {
    return -1;  // 如果总油量差小于0，直接返回-1
} else {
    return startIndex;
}
```

1. `totalSum` 判断

   ：

   - 如果总油量差 `totalSum < 0`，说明无论从哪个站点出发都无法完成一圈，直接返回 `-1`。
   - 如果 `totalSum >= 0`，说明存在解。

2. `startIndex` 的合理性

   ：

   - `startIndex` 是在 `curSum < 0` 时更新的。更新的规则是将起点设为 `i + 1`。
   - 如果 `startIndex == gas.length`（比如最后一次更新时 `i == gas.length - 1`），实际上这表示无解（全局油量差满足但局部不满足）。但 **`gas.length` 表示整个数组长度，不是有效的索引值**。

------

### **为何答案不会是 `gas.length`？**

- 在 `totalSum >= 0` 的情况下，`startIndex` 一定指向某个有效的加油站索引。

- 如果 

  ```
  startIndex == gas.length
  ```

  ：

  - 说明程序从未找到一个合适的起点，实际上 `totalSum` 必然为负，此时程序会提前返回 `-1`。

- **关键点**：程序保证了返回的 `startIndex` 是一个有效的加油站索引。

------

### **举个例子验证**

输入：

```
java复制代码gas  = [1, 2, 3, 4, 5];
cost = [3, 4, 5, 1, 2];
```

执行过程：

1. 初始值：`totalSum = 0`, `curSum = 0`, `startIndex = 0`。
2. 遍历：
   - `i = 0`：`curSum = -2`，更新 `startIndex = 1`，`curSum = 0`。
   - `i = 1`：`curSum = -2`，更新 `startIndex = 2`，`curSum = 0`。
   - `i = 2`：`curSum = -2`，更新 `startIndex = 3`，`curSum = 0`。
   - `i = 3`：`curSum = 3`。
   - `i = 4`：`curSum = 6`。
3. 检查 `totalSum = 3`，满足条件，返回 `startIndex = 3`。

------

### **总结**

- `startIndex = gas.length` 仅是内部变量的一种可能性，但在逻辑上绝不会导致最终结果为 `gas.length`。
- 程序要么返回一个有效的起点（0 至 `gas.length - 1`），要么返回 `-1` 表示无解。





# 假如数组长度是50，通过程序发现0-25加油站点的cursum<0,说明0-25都不能作为答案，此时将26进行尝试，发现26-49得到的cursum>0，按照程序逻辑，这样就会返回26作为答案，为什么27-49之间的数不会成为答案呢？



**摘自b站：**

**因为当start = i+1, 且这个start没有被后序的更新替代，则说明从start到数组结束位置（gas.size()-1）之间的cursum为正数，若记该sum为B，start之前的sum为A，那么A+B=totalSum, 已知totalSum>=0, A<0, B>0, 所以B>-A, 走完一圈的B+A>=0**



## gpt的回答

这是一个非常好的问题，让我们从程序逻辑上分析为什么 **26** 会成为答案，而 **27-49** 不会。

------

### **程序逻辑关键点：**

1. **`curSum < 0` 时的处理**：

   - 如果某个起点的累计油量差 `curSum` 小于 0，意味着从当前起点到当前位置的路径无法走完，因此程序会放弃这个起点，并尝试从下一个位置重新开始。

   - 更新逻辑是：

     ```
     startIndex = i + 1; // 尝试从下一个位置开始
     curSum = 0; // 清空当前油量差
     ```

   - 这保证了从新的 `startIndex` 开始计算的 `curSum` 是独立的，且仅考虑后续站点的油量差。

2. **从 `startIndex` 到数组末尾可以完成循环**：

   - 如果从某个 

     ```
     startIndex
     ```

      开始能成功绕一圈，那么说明：

     - 以 `startIndex` 为起点，走到最后一站时，剩余油量是非负的。
     - 此时，通过累加 `totalSum` 已经验证了全局油量差是否非负（`totalSum >= 0`）。
     - 因此，无需再考虑后续的站点是否可以成为起点，因为如果它们能绕一圈，之前的站点也必然可以。

3. **为什么 `27-49` 不会是答案？**

   - 当程序从 **`26`** 开始尝试，发现从 `26` 到 `49` 累计的 `curSum` 是非负的，且 `totalSum >= 0`，这已经说明整个环路可以完成。
   - 如果某个 `startIndex` 可以绕一圈，那么它之前的任何一个站点（如 `27-49`）都无法作为起点，否则程序在这些站点之前就已经跳过它们了。
   - 换句话说，`27-49` 的路径是包含在从 `26` 开始的一圈内的，它们的有效性已经被包含在从 `26` 开始的判断中。

------

### **数学证明**

假设：

- `gas[i]` 是加油站的油量，`cost[i]` 是消耗的油量。
- `diff[i] = gas[i] - cost[i]` 是每个加油站的净油量差。

当从 `startIndex = 26` 开始，到达 `n - 1`，并回到起点时：

- 我们已经验证了从 `26` 到 `49` 的路径累计 `curSum` 非负，且 `totalSum >= 0`。
- 如果 `27` 作为起点能够绕一圈，这意味着从 `27` 到 `49`，再回到 `26` 的路径也是非负的，这与程序跳过 `27` 的逻辑矛盾（因为 `curSum` 必须在 `26` 开始尝试时已经覆盖了 `27` 的有效性）。

------

### **程序行为的归纳**

- 程序总是从左到右扫描，尝试最早的可能起点。
- 一旦发现一个起点 `startIndex` 能绕一圈完成任务，后面的站点就不需要重新验证了，因为从左到右的扫描逻辑已经确保前面的可能性是最优解。

------

### **总结**

在您的例子中：

- 程序从 `0-25` 均尝试后，发现 `curSum < 0`，放弃这些站点。
- 尝试从 `26` 开始，发现可以绕一圈。
- 由于 `27-49` 的路径已经包含在 `26` 的判断中，程序不需要也不会重新选择它们作为起点。这就是为什么最终答案是 **26** 而非 `27-49`。