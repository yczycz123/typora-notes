

知识点：洪水填充



[827. 最大人工岛 - 力扣（LeetCode）](https://leetcode.cn/problems/making-a-large-island/description/)



[算法讲解058【必备】洪水填充_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VF411S7RH/?spm_id_from=333.1391.0.0&vd_source=96c1635797a0d7626fb60e973a29da38)





# 自己写的算法，部分用例超时了

```java
class Solution {
    // 用于存储当前最大的岛屿面积
    int maxS;

    public int largestIsland(int[][] grid) {
        // 初始化最大面积为最小值（确保能正确比较和更新）
        maxS = Integer.MIN_VALUE;

        // 获取网格的行数和列数
        int m = grid.length;
        int n = grid[0].length;

        // 遍历整个网格的每一个格子
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 如果当前格子是 0，可以将其转化为 1
                if (grid[i][j] == 0) {
                    // 将当前格子从 0 修改为 1，模拟新增陆地的情况
                    grid[i][j] = 1;

                    // 创建一个访问数组，用于标记 DFS 中已经访问过的格子
                    boolean[][] visit = new boolean[m][n];

                    // 通过 DFS 计算当前岛屿的面积，并更新最大岛屿面积
                    maxS = Math.max(maxS, dfs(grid, i, j, m, n, visit));

                    // 恢复格子的值为 0，回溯到原始状态，准备处理下一个格子
                    grid[i][j] = 0;
                }
            }
        }

        // 如果遍历完所有格子后，最大面积仍为最小值，说明整个网格全是 1
        // 此时直接返回网格的总面积 m * n（即整个网格已经是一个完整的大岛屿）
        return maxS == Integer.MIN_VALUE ? m * n : maxS;
    }

    /**
     * 深度优先搜索（DFS）用于计算从某一格子开始的岛屿面积
     *
     * @param grid  当前网格
     * @param i     当前格子的行号
     * @param j     当前格子的列号
     * @param m     网格的总行数
     * @param n     网格的总列数
     * @param visit 访问数组，用于标记哪些格子已经被访问过，防止重复计算
     * @return 从当前格子出发可以连通的岛屿的总面积
     */
    public int dfs(int[][] grid, int i, int j, int m, int n, boolean[][] visit) {
        // 检查边界条件：
        // 1. 当前格子超出了网格的范围（行或列不合法）
        // 2. 当前格子不是陆地（值不为 1）
        // 3. 当前格子已经被访问过（防止重复计算）
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] != 1 || visit[i][j]) {
            return 0; // 不满足条件，返回面积为 0
        }

        // 标记当前格子为已访问
        visit[i][j] = true;

        // 递归搜索当前格子上下左右四个方向，并计算各方向的岛屿面积
        int topS = dfs(grid, i - 1, j, m, n, visit);    // 上
        int underS = dfs(grid, i + 1, j, m, n, visit);  // 下
        int leftS = dfs(grid, i, j - 1, m, n, visit);   // 左
        int rightS = dfs(grid, i, j + 1, m, n, visit);  // 右

        // 返回当前格子的总面积，包括自身面积（1）以及四个方向的岛屿面积之和
        return topS + underS + leftS + rightS + 1;
    }
}

```





# 并查集试试超不超时





# 优化的正确解答
