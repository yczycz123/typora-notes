

知识点：Dijkstra算法



[1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/description/)



[算法讲解064【必备】Dijkstra算法、分层图最短路_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Cm4y1g77W/?spm_id_from=333.1391.0.0&vd_source=96c1635797a0d7626fb60e973a29da38)



几乎也算是Dijkstra算法的模板题目



```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        // 获取矩阵的行数和列数
        int m = heights.length;
        int n = heights[0].length;
        
        // 创建一个二维数组，用来记录从起点到每个位置的最小代价（最小努力）
        int[][] distance = new int[m][n];
        
        // 创建一个二维数组，用来标记每个位置是否已经被访问过
        boolean[][] visited = new boolean[m][n];
        
        // 初始化distance数组，将所有位置的最小代价初始化为最大值（无穷大）
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = Integer.MAX_VALUE;
            }
        }
        
        // 定义四个方向的偏移量，分别是上、右、下、左
        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, 1, 0, -1};
        
        // 使用优先队列来进行贪心策略（按代价最小的优先）
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        
        // 起点(0, 0)的代价为0，将起点加入队列
        distance[0][0] = 0;
        queue.add(new int[]{0, 0, 0});
        
        // 开始遍历队列
        while (!queue.isEmpty()) {
            // 获取当前队列中的最小代价节点
            int[] cur = queue.poll();
            int curX = cur[0];
            int curY = cur[1];
            int curDistance = cur[2];
            
            // 如果当前位置已经被访问过，跳过
            if (visited[curX][curY]) {
                continue;
            }
            
            // 剪枝策略：如果当前已经到达终点(右下角)，直接返回结果
            if (curX == m - 1 && curY == n - 1) {
                return curDistance;
            }
            
            // 遍历四个方向，尝试更新相邻位置的最小代价
            for (int i = 0; i < 4; i++) {
                int nX = curX + dx[i];
                int nY = curY + dy[i];
                
                // 检查相邻的位置是否在边界内
                if (nX >= 0 && nX < m && nY >= 0 && nY < n) {
                    // 如果该位置尚未访问过，并且能够通过当前路径降低该位置的代价
                    if (!visited[nX][nY] && Math.max(curDistance, Math.abs(heights[curX][curY] - heights[nX][nY])) < distance[nX][nY]) {
                        // 更新该位置的最小代价
                        distance[nX][nY] = Math.max(curDistance, Math.abs(heights[curX][curY] - heights[nX][nY]));
                        // 将该位置添加到队列中
                        queue.add(new int[]{nX, nY, distance[nX][nY]});
                    }
                }
            }
            
            // 标记当前节点为已访问
            visited[curX][curY] = true;
        }
        
        // 返回右下角的最小代价（努力值）
        return distance[m - 1][n - 1];
    }
}

```





## 代码注释说明：

1. **数据结构解释**：
   - `distance` 数组用于记录从起点到当前位置的最小努力值。
   - `visited` 数组用于标记某个位置是否已经被访问过，避免重复计算。
   - `PriorityQueue` 是一个优先队列，用于按代价（即当前的最大高度差）最小的路径进行贪心遍历。
2. **核心逻辑**：
   - 使用 **Dijkstra 算法** 的变种来寻找从起点到终点的最小努力路径。每次选择当前代价最小的路径扩展。
   - 对于每一个位置，我们通过四个方向进行扩展（上、右、下、左），更新相邻位置的最小代价。
   - **剪枝策略**：一旦到达终点，即 `(m - 1, n - 1)`，直接返回结果，避免不必要的计算。
   - 在更新路径时，计算当前路径的代价是通过 `Math.max(curDistance, Math.abs(heights[curX][curY] - heights[nX][nY]))` 来处理的。代价是走过的路径中的最大高度差。
3. **边界检查**：在扩展相邻节点时，检查节点是否超出了边界。

这种方法的时间复杂度大约是 `O(m * n * log(m * n))`，其中 `m` 和 `n` 是矩阵的行和列数。



## 复杂度分析

分析时间复杂度时，我们要考虑到每个操作的次数以及它们的执行成本。对于这段代码，主要涉及到以下几个部分：

### 1. **优先队列（PriorityQueue）操作**

- 在代码中，使用了一个优先队列来按最小代价（路径上的最大高度差）进行贪心遍历。优先队列的操作时间复杂度主要由插入操作和删除操作组成：
  - **插入操作**（`queue.add()`）：时间复杂度是 `O(log k)`，其中 `k` 是队列中的元素个数。
  - **删除操作**（`queue.poll()`）：时间复杂度是 `O(log k)`，同样，`k` 是队列中的元素个数。

由于队列的大小最多会是 `m * n`（即矩阵中的所有格子），因此每次操作的时间复杂度是 `O(log(m * n))`。

### 2. **队列中的元素**

- 每个格子（位置）在最坏情况下会被添加到队列一次。每个格子的代价都会被更新并插入队列，因此在最坏的情况下，队列中会有 `m * n` 个元素。

### 3. **邻接点检查**

- 对于每个位置（格子），我们会检查它的四个邻接点（上、下、左、右）。每个位置的邻接点检查和更新代价的操作都只会发生常数次，即 `O(1)` 次。

### 4. **访问的次数**

- 每个格子最多被访问一次。当一个位置被访问时，它就会被标记为已访问，并且不会再加入队列进行处理。所以，每个格子的访问次数是有限的，不会重复。

### 综合分析：

- 每次从队列中弹出一个元素时，需要做的是对其四个邻接点进行处理。每个邻接点的处理是常数时间 `O(1)`，而插入或删除操作的时间复杂度是 `O(log(m * n))`。
- 最坏情况下，队列中的元素总数为 `m * n`，所以总的时间复杂度为： O((m×n)×log⁡(m×n))=O(m×n×log⁡(m×n))O((m \times n) \times \log(m \times n)) = O(m \times n \times \log(m \times n))O((m×n)×log(m×n))=O(m×n×log(m×n))

### 空间复杂度：

- `distance` 数组需要 `O(m * n)` 的空间来存储每个位置的最小代价。
- `visited` 数组也需要 `O(m * n)` 的空间来存储每个位置的访问状态。
- 优先队列中最多有 `O(m * n)` 个元素，因此空间复杂度也为 `O(m * n)`。

### 总结：

- **时间复杂度**：`O(m * n * log(m * n))`
- **空间复杂度**：`O(m * n)`

这种复杂度分析基于 Dijkstra 算法的变种，其中最主要的开销是优先队列操作。