

知识点：洪水填充



[130. 被围绕的区域 - 力扣（LeetCode）](https://leetcode.cn/problems/surrounded-regions/)



[算法讲解058【必备】洪水填充_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VF411S7RH/?spm_id_from=333.1391.0.0&vd_source=96c1635797a0d7626fb60e973a29da38)







```java
class Solution {
    /**
     * 主方法：将被包围的 'O' 转换为 'X'
     * 
     * @param board 二维字符数组，表示棋盘
     */
    public void solve(char[][] board) {
        int m = board.length; // 获取棋盘的行数
        int n = board[0].length; // 获取棋盘的列数

        // 第一列和最后一列：遍历每一行的边界 'O'
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') { // 检查当前行的第一列是否为 'O'
                dfs(board, i, 0, m, n); // 从边界开始进行深度优先搜索
            }
            if (board[i][n - 1] == 'O') { // 检查当前行的最后一列是否为 'O'
                dfs(board, i, n - 1, m, n); // 从边界开始进行深度优先搜索
            }
        }

        // 第一行和最后一行：遍历每一列的边界 'O'
        for (int j = 1; j < n - 1; j++) { // 避免重复检查左上角和右上角
            if (board[0][j] == 'O') { // 检查第一行的当前列是否为 'O'
                dfs(board, 0, j, m, n); // 从边界开始进行深度优先搜索
            }
            if (board[m - 1][j] == 'O') { // 检查最后一行的当前列是否为 'O'
                dfs(board, m - 1, j, m, n); // 从边界开始进行深度优先搜索
            }
        }

        // 遍历整个棋盘，将内部的 'O' 变为 'X'，将标记为 'F' 的恢复为 'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') { // 被包围的 'O' 转换为 'X'
                    board[i][j] = 'X';
                }
                if (board[i][j] == 'F') { // 标记为 'F' 的表示未被包围的 'O'，恢复为 'O'
                    board[i][j] = 'O';
                }
            }
        }
    }

    /**
     * 深度优先搜索（DFS）方法
     * 
     * @param board 二维字符数组，表示棋盘
     * @param i 当前格子的行索引
     * @param j 当前格子的列索引
     * @param m 棋盘的行数
     * @param n 棋盘的列数
     */
    public void dfs(char[][] board, int i, int j, int m, int n) {
        // 边界条件：超出棋盘范围或当前格子不是 'O'，直接返回
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || board[i][j] != 'O') {
            return;
        }

        // 将当前格子标记为 'F'，表示它是与边界连通的 'O'
        board[i][j] = 'F';

        // 递归向四个方向扩展
        dfs(board, i - 1, j, m, n); // 向上扩展
        dfs(board, i + 1, j, m, n); // 向下扩展
        dfs(board, i, j - 1, m, n); // 向左扩展
        dfs(board, i, j + 1, m, n); // 向右扩展
    }
}
```





### 详细注释说明

1. **主方法 `solve`：**

   - 目的：将棋盘中被包围的 `'O'` 转换为 `'X'`，保留未被包围的 `'O'`。

   - **第一步**：遍历棋盘的四条边界，对每一个边界上的 `'O'` 进行深度优先搜索（DFS），将与边界连通的 `'O'` 标记为 `'F'`。

   - 第二步

     ：遍历整个棋盘：

     - 如果遇到 `'O'`，说明它是被包围的，转换为 `'X'`。
     - 如果遇到 `'F'`，说明它是未被包围的 `'O'`，恢复为 `'O'`。

2. **深度优先搜索 `dfs`：**

   - **作用**：从当前格子出发，将所有与之相连的 `'O'` 标记为 `'F'`，以区分未被包围的 `'O'`。
   - 递归停止条件：
     - 当前格子超出棋盘范围。
     - 当前格子不是 `'O'`（可能是 `'X'` 或已经标记为 `'F'`）。
   - **标记当前格子**：将当前格子设置为 `'F'`，表示它是未被包围的 `'O'`。
   - **递归方向**：依次向上、向下、向左、向右扩展搜索。

3. **程序逻辑：**

   - 边界的 `'O'` 一定不会被包围，因此通过 DFS 将所有与边界连通的 `'O'` 标记为 `'F'`。
   - 在遍历棋盘时：
     - 未被标记的 `'O'` 一定是被包围的，转为 `'X'`。
     - 被标记的 `'F'` 恢复为 `'O'`。

4. **时间复杂度和空间复杂度**：

   - **时间复杂度**：`O(m * n)`，其中 `m` 和 `n` 分别为棋盘的行数和列数，DFS 每个格子最多访问一次。
   - **空间复杂度**：`O(m * n)`，递归调用栈的最大深度取决于棋盘大小。

### 示例

输入：

```
X X X X
X O O X
X X O X
X O X X
```

输出：

```
X X X X
X X X X
X X X X
X O X X
```

过程：

- 边界连通的 `'O'` 标记为 `'F'`。
- 遍历棋盘，将被包围的 `'O'` 转换为 `'X'`，恢复 `'F'` 为 `'O'`。