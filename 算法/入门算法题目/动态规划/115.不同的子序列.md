[代码随想录](https://www.programmercarl.com/0115.不同的子序列.html#算法公开课)







```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();

        //dp[i][j]表示和t的前j个字符作为子序列在字符串s的前i个字符出现的次数
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = 1;
        }


        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[m][n] % 1000000007;
    }
}
```





------

### **1. 状态定义**

我们用 `dp[i][j]` 表示：

- **字符串 `s` 的前 `i` 个字符**中，**字符串 `t` 的前 `j` 个字符**作为子序列出现的次数。

这表示：

- 如果 `i = 0`，`dp[0][j]` 表示从空字符串 `s` 中找出 `t` 的前 `j` 个字符的次数。
- 如果 `j = 0`，`dp[i][0]` 表示从 `s` 的前 `i` 个字符中找出 `t` 的空子序列的次数。

#### 1.1 为什么这样定义？

因为子序列问题涉及部分匹配，而不是完全匹配。我们通过让状态 `dp[i][j]` 分别表示 **`s[0..i-1]` 和 `t[0..j-1]` 的子序列出现次数**，可以逐步递推出最终的结果。

------

### **2. 初始化**

初始化的部分是设置边界条件。

#### 2.1 为什么 `dp[i][0] = 1`？

- 当 `t` 是空字符串时（`j = 0`），不管 `s` 是什么，都有 **1 种子序列匹配方式**（即：不选任何字符）。

- 所以，对于任意的 `i`：
  $$
  dp[i][0]=1
  $$
  

#### 2.2 为什么 `dp[0][j] = 0`（当 `j > 0`）？

- 当 `s` 是空字符串（`i = 0`）时，不可能找出 `t` 的任何非空子序列。所以对于任意的 `j > 0`：
  $$
  dp[0][j]=0
  $$
   

------

### **3. 状态转移方程**

我们从两种可能性来分析如何转移状态。

#### 3.1 如果 `s[i-1] == t[j-1]`

这时，`s[i-1]` 和 `t[j-1]` 的字符相等，我们有两种选择：

1. 选用 `s[i-1]` 和 `t[j-1]` 匹配：

   如果我们选择用 `s[i-1]` 和 `t[j-1]` 匹配，则问题就变成了求解 `dp[i-1][j-1]`，即匹配 `s[0..i-2]` 和 `t[0..j-2]`。

2. 不选用 `s[i-1]`：

   如果我们不选择用 `s[i-1]` 和 `t[j-1]` 匹配，则问题就变成了求解 `dp[i-1][j]`，即匹配 `s[0..i-2]` 和 `t[0..j-1]`。

综合这两种情况：
$$
dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
$$


#### 3.2 如果 `s[i-1] != t[j-1]`

这时，`s[i-1]` 和 `t[j-1]` 的字符不相等，我们不能用 `s[i-1]` 和 `t[j-1]` 匹配。只能跳过 `s[i-1]`，继续匹配 `s[0..i-2]` 和 `t[0..j-1]`，即：
$$
dp[i][j] =  dp[i-1][j]
$$


------

### **4. 推导总结**

综合上述两种情况，状态转移方程为：



如果 `s[i-1] == t[j-1]`（当前字符相等）： 
$$
dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
$$


- `dp[i-1][j-1]` 表示选择 `s[i-1]` 来匹配 `t[j-1]`；
- `dp[i-1][j]` 表示不选择 `s[i-1]`，直接匹配 `s[0..i-2]` 和 `t[0..j-1]`。

如果 `s[i-1] != t[j-1]`（当前字符不相等）：
$$
dp[i][j] =  dp[i-1][j]
$$

- 表示跳过 `s[i-1]`，继续用 `s[0..i-2]` 匹配 `t[0..j-1]`。



------

### **5. 为什么这样设计初始化和转移方程？**

1. 初始化 `dp[i][0] = 1`，是因为空字符串 `t` 可以从任意 `s[0..i-1]` 中匹配。
2. 初始化 `dp[0][j] = 0`，是因为空字符串 `s` 不可能匹配任何非空字符串 `t`。
3. 转移方程考虑了两种情况（字符相等和字符不相等），确保了对每一种可能的子序列匹配方式都进行了完整统计。

通过这种设计，状态转移方程逐步从小规模问题（前缀子问题）扩展到完整问题，从而得到正确的答案。